{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"Cardiotensor <p>A Python package to quantify and visualize 3D cardiomyocyte orientation in heart imaging datasets</p> <p> </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Cardiotensor is a user-friendly and memory-efficient toolkit designed for analyzing the orientation of cardiomyocyte fibers in large heart imaging datasets. It uses advanced image processing techniques to help researchers to accurately quantify 3D cardiomyocyte orientations with high efficiency.</p>"},{"location":"#installation","title":"Installation","text":"<p>cardiotensor is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal and install cardiotensor with:</p> <pre><code>pip install cardiotensor\n</code></pre> <p>\u26a0\ufe0f Require python 3.10 or newer</p>"},{"location":"#documentation","title":"Documentation","text":"<p>cardiotensor's documentation is available at josephbrunet.fr/cardiotensor/</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Have a look at our simple example that runs you through all the commands of the package</p> <p> Overview of the <code>cardiotensor</code> pipeline for 3D cardiac orientation analysis and tractography. (a) Input data consist of a whole\u2011 or partial\u2011heart volume and, optionally, a binary mask to restrict analysis to myocardial tissue.         (b) Local cardiomyocyte orientation is derived by 3D structure tensor computation and eigenvector decomposition.         The third eigenvector (smallest eigenvalue) is visualized as arrows, color\u2011coded by helix angle (HA); inset shows a zoom of the ventricular septum highlighting transmural fiber rotation.         (c) After transforming to a cylindrical coordinate system aligned with the left ventricle, voxel\u2011wise HA, transverse angle (TA), and fractional anisotropy (FA) maps are computed for quantitative analysis.         (d) Streamline tractography generated from the eigenvector field reveals continuous cardiomyocyte bundles throughout the heart, color\u2011coded by HA.      </p>"},{"location":"#more-information","title":"More Information","text":"<p>This package uses the structure-tensor package to calculate the structure tensor, extending its capabilities for cardiac imaging.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you encounter a bug or have suggestions for new features:</p> <ul> <li>Report an Issue: Open an issue in the repository.</li> <li>Submit a Pull Request: Fork the repository, make changes, and submit a pull request.</li> </ul> <p>For major changes, please discuss them in an issue first.</p>"},{"location":"#contact","title":"Contact","text":"<p>For questions, feedback, or support, please contact the maintainers at [j.brunet@ucl.ac.uk].</p>"},{"location":"#reference","title":"Reference","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731. [PDF]</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/","title":"Citing","text":"<p>If you use <code>cardiotensor</code> in your research, please cite the related paper as follow:</p>"},{"location":"citing/#apa-format","title":"APA Format","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731</p>"},{"location":"citing/#bibtex-format","title":"BibTeX Format","text":"<p>For LaTeX users, please include the following BibTeX entry to reference <code>cardiotensor</code>:</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/#citation-examples-in-various-formats","title":"Citation Examples in Various Formats","text":"<ol> <li> <p>MLA Format    Brunet, Joseph, et al. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology, vol. 312, no. 1, 2024, p. e232731.</p> </li> <li> <p>Chicago Style    Brunet, Joseph, Andrew C. Cook, Claire L. Walsh, James Cranley, Paul Tafforeau, Klaus Engel, Owen Arthurs, Camille Berruyer, Emer Burke O\u2019Leary, Alexandre Bellier, et al. 2024. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology 312 (1): e232731.</p> </li> <li> <p>Harvard Format    Brunet, J., Cook, A.C., Walsh, C.L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al., 2024. Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), p.e232731.</p> </li> </ol>"},{"location":"citing/#why-cite-cardiotensor","title":"Why Cite <code>cardiotensor</code>?","text":"<p>Citing <code>cardiotensor</code> in your research helps other researchers to discover and reference the software, support continued development, and acknowledges the work invested in creating this package. Proper citations also contribute to the visibility and impact of the <code>cardiotensor</code> project.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to the cardiotensor project! We welcome contributions of all kinds, including bug fixes, feature suggestions, documentation improvements, and more. Follow the guidelines below to ensure a smooth contribution process.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the Repository</p> <ul> <li>Go to the GitHub repository and click the \"Fork\" button.</li> <li>Clone your fork locally:     <pre><code>git clone https://github.com/&lt;your-username&gt;/cardiotensor.git\ncd cardiotensor\n</code></pre></li> </ul> </li> <li> <p>Create a Branch</p> <ul> <li>Create a new branch for your feature or bug fix:     <pre><code>git checkout -b my-feature-branch\n</code></pre></li> </ul> </li> <li> <p>Install Dependencies</p> <ul> <li>Ensure you have all required dependencies installed. You can use the provided development dependencies:     <pre><code>pip install -e .[dev]\n</code></pre></li> </ul> </li> <li> <p>Make Your Changes</p> <ul> <li>Make your changes to the codebase, documentation, or both.</li> <li>Follow PEP8 standards for Python code.</li> </ul> </li> <li> <p>Run Tests</p> <ul> <li>Ensure all tests pass and that your contribution does not introduce any issues:     <pre><code>pytest\n</code></pre></li> <li>If you add new features, include corresponding tests.</li> </ul> </li> <li> <p>Commit Your Changes</p> <ul> <li>Write clear and concise commit messages:     <pre><code>git add .\ngit commit -m \"Add feature: XYZ\"\n</code></pre></li> </ul> </li> <li> <p>Push and Create a Pull Request</p> <ul> <li>Push your branch to your fork:     <pre><code>git push origin my-feature-branch\n</code></pre></li> <li>Go to the original repository and create a Pull Request (PR).</li> <li>Provide a clear description of your changes and why they are necessary.</li> </ul> </li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<p>To maintain a consistent and readable codebase, please adhere to the following guidelines:</p> <ul> <li>PEP 8: Follow PEP8 coding style standards for Python code.</li> <li>Type Annotations: Include type hints for function arguments and return values.</li> <li>Docstrings: Provide clear docstrings for functions and classes. We recommend using the Google docstring style.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Be Respectful: Treat all contributors with respect and professionalism.</li> <li>Follow Standards: Ensure your contributions align with the project's coding and documentation standards.</li> <li>Keep It Simple: Focus on making the project easier to use and maintain.</li> <li>Documentation: Update documentation if your changes affect the usage or functionality of the project.</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter a bug or have a suggestion, please open an issue. Include as much detail as possible:</p> <ul> <li>Steps to reproduce the issue.</li> <li>Expected and actual results.</li> <li>Your environment (e.g., Python version, OS).</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>For questions or further assistance, feel free to reach out to the project maintainers via the email listed in the repository.</p> <p>We appreciate your contributions and support in making cardiotensor better!</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>To help you get started with cardiotensor, we'll cover a few important topics:</p> <ul> <li>Installing cardiotensor</li> <li>First steps after installation</li> <li>A simple example</li> </ul> <p>Read on, or jump ahead to another section:</p> <ul> <li>Use the reference documentation to find details about something specific.</li> </ul>"},{"location":"getting-started/examples/","title":"Example","text":"<p>This example demonstrates how to use the cardiotensor package with the example provided in the repository. This example will help you understand how to process input data, compute fiber orientations, and visualize results.</p>"},{"location":"getting-started/examples/#example-directory-overview","title":"Example Directory Overview","text":"<p>The <code>./examples/</code> directory contains:</p> <ul> <li>Datasets: Cropped 3D volumes and binary masks for testing and experimentation.</li> <li>Configuration File: A pre-filled <code>parameters_example.conf</code> file for running the workflows.</li> </ul>"},{"location":"getting-started/examples/#data","title":"Data","text":"<ol> <li> <p>Heart Volume:</p> <ul> <li>Path: <code>./data/635.2um_LADAF-2021-17_heart_overview_/</code></li> <li>Description: A downsampled 3D heart image volume designed for testing. The full-resolution dataset is available at the Human Organ Atlas.</li> </ul> </li> <li> <p>Binary Mask:</p> <ul> <li>Path: <code>./data/mask/</code></li> <li>Description: A binary mask used for segmenting the heart from the background.</li> </ul> </li> </ol>"},{"location":"getting-started/examples/#running-the-examples","title":"Running the Examples","text":""},{"location":"getting-started/examples/#installation","title":"Installation","text":"<p>Note</p> <p>See Installation</p> <ol> <li> <p>Clone the repository and install the package:     <pre><code>$ git clone https://github.com/JosephBrunet/cardiotensor.git\n$ cd cardiotensor\n$ pip install .\n</code></pre></p> </li> <li> <p>Navigate to the <code>examples</code> directory:     <pre><code>$ cd examples\n</code></pre></p> </li> </ol>"},{"location":"getting-started/examples/#processing-a-test-slice","title":"Processing a Test Slice","text":"<ol> <li>Open <code>parameters_example.conf</code> and set <code>TEST = True</code> in the <code>[TEST]</code> section.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the following command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>The output will be displayed as a plot for a single slice:</li> </ol> Result from processing a single test slice."},{"location":"getting-started/examples/#processing-the-entire-volume","title":"Processing the Entire Volume","text":"<ol> <li>Set <code>TEST = False</code> in <code>parameters_example.conf</code>.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>Outputs will be saved in the <code>./output</code> directory with the following structure:     <pre><code>./output\n\u251c\u2500\u2500 HA          # Helix angle results\n\u251c\u2500\u2500 IA          # Intrusion angle results\n\u251c\u2500\u2500 FA          # Fractional anisotropy results\n\u2514\u2500\u2500 eigen_vec   # 3rd Eigenvectors\n</code></pre></li> </ol>"},{"location":"getting-started/examples/#visualizing-transmural-profiles","title":"Visualizing Transmural Profiles","text":"<ol> <li> <p>Use the <code>cardio-analysis</code> command:     <pre><code>$ cardio-analysis ./parameters_example.conf 150\n</code></pre>     Replace <code>150</code> with the slice number you wish to analyze.</p> </li> <li> <p>The GUI will appear, allowing you to:</p> <ul> <li>Define a transmural profile line.</li> <li>Adjust parameters like <code>Angle range</code> and <code>Number of lines</code>.</li> <li>Plot and export the profile.  Graphical interface for defining transmural profiles. </li> </ul> <p>The generated profile will resemble:</p> <p> Example of a generated transmural profile. </p> </li> </ol>"},{"location":"getting-started/examples/#visualizing-vector-field","title":"Visualizing Vector field","text":"<p>Note</p> <p>WRITE_VECTORS must be equal to True in the Configuration file</p> <p>Once the structure tensor and eigenvectors have been calculated on the whole volume.</p> <ol> <li> <p>Use the <code>cardio-visualize-vector</code> command:     <pre><code>$ cardio-visualize-vector parameters_example.conf --start 120 --stride 6\n</code></pre></p> <ul> <li> <p><code>--start</code> : Show vectors only from slice 120 to the last slice.</p> </li> <li> <p><code>--stride 6</code> : Show only 1 vector out of every 6.</p> </li> </ul> </li> <li> <p>The plot will appear and you will be able to rotate it by dragging left click</p> <p> Vector field visualization from computed structure tensors using Fury. </p> </li> </ol>"},{"location":"getting-started/examples/#generating-and-visualizing-streamlines","title":"Generating and visualizing streamlines","text":"<ol> <li> <p>Use the <code>cardio-visualize-vector</code> command to generate the streamlines:     <pre><code>$ cardio-generate-streamlines parameters_example.conf --seeds 10000 --start 150\n</code></pre></p> <ul> <li> <p><code>--start</code> : Show vectors only from slice 120 to the last slice.</p> </li> <li> <p><code>--seeds</code> : Number of seeds to start streamlines</p> </li> </ul> <p>Note</p> <p>The streamlines are generated in <code>output/streamlines.trk</code></p> </li> <li> <p>Use the <code>cardio-visualize-streamlines</code> command to plot the streamlines:     <pre><code>$ cardio-visualize-streamlines parameters_example.conf --line-width 1\n</code></pre></p> <ul> <li><code>--line-width</code> : The width of the streamline in the plot.</li> </ul> </li> </ol> Streamline visualization using Fury."},{"location":"getting-started/examples/#notes","title":"Notes","text":"<ul> <li>The provided dataset is for demonstration purposes only.</li> <li>Modify parameters in <code>parameters_example.conf</code> (e.g., <code>SIGMA</code>, <code>RHO</code>) to suit your data.</li> </ul>"},{"location":"getting-started/first-steps/","title":"Verify the installation","text":"<p>After installing cardiotensor, you can verify that cardiotensor is installed correctly by running the command:</p> <pre><code>$ cardio-tensor --help\nusage: cardio-tensor [-h] [--start_index START_INDEX]\n                  [--end_index END_INDEX] [--gpu]\n                  [conf_file_path]\n\nThis script computes orientation for a 3D volume based on the provided configuration file.\n\n...\n</code></pre> <p>You should see a help menu listing the available commands.</p> <p>If no errors occur, the installation is successful. You can then check out our simple example to get familiar with the commands of cardiotensor</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Cardiotensor is a powerful and user-friendly toolkit for analyzing the orientation of cardiomyocites fibers in the heart</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> </ul>"},{"location":"getting-started/installation/#installing-with-pip-recommended","title":"Installing with pip recommended","text":"<p>cardiotensor is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal and install cardiotensor with:</p> <pre><code>pip install cardiotensor\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>To install cardiotensor from source, follow these steps:</p> <ol> <li> <p>Clone the repository from GitHub:</p> <pre><code>$ git clone https://github.com/JosephBrunet/cardiotensor.git\n</code></pre> </li> <li> <p>Navigate to the cloned repository directory:</p> <pre><code>$ cd cardiotensor\n</code></pre> </li> <li> <p>Install the package using pip:</p> <pre><code>$ pip install -e .  # (1)!\n</code></pre> <ol> <li>The <code>-e</code> flag in <code>pip install -e .</code> installs the package in editable mode, allowing changes to the source code to be immediately reflected without reinstallation.</li> </ol> </li> </ol>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>If you need to remove cardiotensor from your system, follow these steps:</p> <pre><code>$ pip uninstall cardio-tensor\n</code></pre> <p>This should remove cardiotensor from your environment.</p>"},{"location":"getting-technical/","title":"Getting Technical","text":"<p>This section provides a deeper understanding of how <code>cardiotensor</code> works, including coordinate systems, angle definitions, structure tensor theory, and tractography method. It is intended for advanced users and developers.</p>"},{"location":"getting-technical/#topics-covered","title":"Topics Covered","text":"<ul> <li> <p>Conventions</p> </li> <li> <p>Structure Tensor: Mathematical background on the structure tensor and eigen decomposition</p> </li> <li> <p>Angle Definitions: Detailed explanation of helix and intrusion angles</p> </li> <li> <p>Fractional Anisotropy</p> </li> <li> <p>Tractography</p> </li> </ul>"},{"location":"getting-technical/angles/","title":"Angle Definitions","text":"<p>This page explains how helix and intrusion angles are calculated from the 3D eigenvector field derived by <code>cardiotensor</code>.</p>"},{"location":"getting-technical/angles/#coordinate-system","title":"Coordinate System","text":"<p>A transformation to a cylindrical coordinate system is defined for each voxel based on an approximation of the left ventricle (LV) centerline.</p> <ul> <li>Radial (r): outward from the LV center</li> <li>Circumferential (\u03b8): tangential around the ventricle</li> <li>Longitudinal (z): base to apex direction</li> </ul> <p>To compute local fiber angles consistently, all eigenvectors are first rotated into this cylindrical coordinate frame. This alignment is performed using Rodrigues' rotation formula, which computes the minimal-angle rotation that maps the global reference axis (here the z-axis) onto the local longitudinal axis at each point. This allows a robust comparison of orientations across the myocardium.</p>"},{"location":"getting-technical/angles/#helix-angle-ha","title":"Helix Angle (HA)","text":"<p>The helix angle is defined as the angle between the third eigenvector \\( \\vec{v}_3 \\) (smallest eigenvalue direction) and the local circumferential plane.</p> <p>It captures the transmural variation of fiber orientation from epicardium to endocardium.</p> <p>Typical pattern: - ~\u221260\u00b0 at epicardium - ~0\u00b0 in mid-wall - ~+60\u00b0 at endocardium</p>"},{"location":"getting-technical/angles/#intrusion-angle-ia","title":"Intrusion Angle (IA)","text":"<p>The intrusion angle is the angle between \\( \\vec{v}_3 \\) and the tangential plane (longitudinal + circumferential).</p> <p>It captures radial deviation of fiber aggregates and can help identify wall thickening or microstructural disruptions.</p>"},{"location":"getting-technical/angles/#angle-ranges","title":"Angle Ranges","text":"<p>Both angles are reported in degrees: - HA: \u221290\u00b0 to +90\u00b0 - IA: \u221290\u00b0 to +90\u00b0</p> <p>Angles are defined in a left-handed cylindrical coordinate system aligned to the LV.</p>"},{"location":"getting-technical/conventions/","title":"Conventions","text":""},{"location":"getting-technical/conventions/#sign-conventions","title":"Sign conventions","text":"<p>Cardiotensor processes full-field orientation data in 3D volumes. Consistent with NumPy matrix indexing, the position (0, 0, 0) refers to the corner at the top-left of the first slice.</p> <p>This convention is maintained across all processing pipelines, including structure tensor calculation and streamline generation.</p>"},{"location":"getting-technical/conventions/#orientation-fields-and-eigenvectors","title":"Orientation fields and eigenvectors","text":"<p>Eigenvector maps are saved in the shape <code>(3, Z, Y, X)</code>:</p> <ul> <li>3 = x, y, z vector components</li> <li>Each voxel contains the orientation of the 3rd eigenvector (principal myocyte axis)</li> </ul> <p>These vector fields are used for computing helix/intrusion angles, streamlines, and for visualization.</p>"},{"location":"getting-technical/conventions/#units-of-measurement","title":"Units of measurement","text":"<ul> <li>Lengths are expressed in pixels (or voxels for 3D).</li> <li>Angles (helix, intrusion) are in degrees.</li> <li>Fractional anisotropy is dimensionless, ranging from 0 (isotropic) to 1 (highly anisotropic).</li> </ul>"},{"location":"getting-technical/conventions/#image-format","title":"Image format","text":"<p>All image volumes and masks must be provided as image stack files in formats such as <code>TIFF</code>, <code>JP2</code>, <code>PNG</code>, or as single RAW file (<code>MHD</code>).</p> <p>Internally, images are processed as NumPy arrays: <pre><code>volume.shape == (Z, Y, X)\n</code></pre></p> <p>The same format is used throughout the orientation pipeline.</p>"},{"location":"getting-technical/fractional_anisotropy/","title":"Fractional Anisotropy (FA)","text":"<p>Fractional Anisotropy (FA) is a scalar value that quantifies the degree of anisotropy (directional dependence) in a tensor field. In <code>cardiotensor</code>, FA is derived from the structure tensor eigenvalues and helps identify regions with organized myocardial fiber orientation.</p>"},{"location":"getting-technical/fractional_anisotropy/#definition","title":"Definition","text":"<p>Given the ordered eigenvalues of the structure tensor \\(\\lambda_1 \\leq \\lambda_2 \\leq \\lambda_3\\), the FA is computed as:</p> \\[ FA = \\sqrt{\\frac{3}{2}} \\cdot \\frac{\\sqrt{(\\lambda_1 - \\bar{\\lambda})^2 + (\\lambda_2 - \\bar{\\lambda})^2 + (\\lambda_3 - \\bar{\\lambda})^2}}{\\sqrt{\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2}} \\] <p>Where:</p> <ul> <li>\\(\\bar{\\lambda} = (\\lambda_1 + \\lambda_2 + \\lambda_3) / 3\\): mean of the eigenvalues</li> </ul>"},{"location":"getting-technical/fractional_anisotropy/#interpretation","title":"Interpretation","text":"<ul> <li>FA = 0: Isotropic region, where diffusion or structural orientation is equal in all directions (e.g. cavity or noise).</li> <li>FA = 1: Perfectly anisotropic region, structure is highly aligned in one direction (e.g. dense aligned fibers).</li> <li>0 &lt; FA &lt; 1: Varying degrees of anisotropy.</li> </ul> <p>This scalar map can be used to:</p> <ul> <li>Mask low-confidence areas for streamline seeding</li> <li>Identify anatomical regions of high or low alignment</li> <li>Visualize structural organization within the myocardium</li> </ul>"},{"location":"getting-technical/fractional_anisotropy/#output","title":"Output","text":"<p>The FA volume is saved as a single 3D scalar field with the same shape as the input image:</p> <pre><code>fa.shape == (Z, Y, X)\n</code></pre> <p>It can be saved as TIFF or JP2 and visualized with standard volume rendering tools.</p>"},{"location":"getting-technical/fractional_anisotropy/#thresholding-in-tractography","title":"Thresholding in Tractography","text":"<p>FA values can be used to restrict streamline propagation:</p> <ul> <li>Minimum FA threshold: ensures streamlines are seeded and propagated only in structured regions</li> <li>Default values range from 0.1 to 0.2 depending on noise level and resolution</li> </ul>"},{"location":"getting-technical/structure_tensor/","title":"Structure Tensor Computation","text":"<p>The structure tensor is a fundamental tool in 3D image analysis used to estimate local orientation and anisotropy. In <code>cardiotensor</code>, it is computed per voxel to quantify the principal direction of cardiomyocyte aggregates.</p>"},{"location":"getting-technical/structure_tensor/#what-is-a-structure-tensor","title":"What is a Structure Tensor?","text":"<p>The structure tensor \\(S\\) is a 3-by-3 symmetric matrix that summarizes how intensity varies in a local neighborhood of a 3D image. It is defined as:</p> \\[ S = K_\\rho * (\\nabla V_\\sigma \\cdot \\nabla V_\\sigma^T) \\] <p>Where:</p> <ul> <li>\\(V\\): 3D image volume</li> <li>\\(\\nabla V_\\sigma\\): smoothed gradient (via Gaussian derivative with noise scale \\(\\sigma\\))</li> <li>\\(K_\\rho\\): Gaussian kernel with standard deviation \\(\\rho\\) (integration scale)</li> <li>\\(*\\): convolution over a local neighborhood</li> </ul> <p>This matrix encodes orientation and intensity variation.</p>"},{"location":"getting-technical/structure_tensor/#implementation","title":"Implementation","text":"<p>Cardiotensor computes the structure tensor using the structure-tensor Python library.</p> <ul> <li>It supports parallel computation and automatically uses the GPU (via CuPy) if available.</li> <li>CPU-based execution falls back to NumPy for full compatibility.</li> <li>This makes orientation estimation fast and scalable on large datasets.</li> </ul>"},{"location":"getting-technical/structure_tensor/#step-by-step-computation","title":"Step-by-Step Computation","text":"<ol> <li> <p>Noise Filtering</p> </li> <li> <p>Compute gradients \\(V_x, V_y, V_z\\) using Gaussian derivative filters (standard deviation \\(\\sigma\\)).</p> </li> <li> <p>Outer Product</p> </li> <li> <p>Form tensor components:</p> <ul> <li>\\(V_x^2, V_y^2, V_z^2, V_xV_y, V_xV_z, V_yV_z\\)</li> </ul> </li> <li> <p>Smoothing</p> </li> <li> <p>Convolve each component with a Gaussian kernel (standard deviation \\(\\rho\\)) to compute final tensor:</p> </li> </ol> \\[ S = \\begin{bmatrix} \\langle V_x^2 \\rangle &amp; \\langle V_x V_y \\rangle &amp; \\langle V_x V_z \\rangle \\\\ \\langle V_x V_y \\rangle &amp; \\langle V_y^2 \\rangle &amp; \\langle V_y V_z \\rangle \\\\ \\langle V_x V_z \\rangle &amp; \\langle V_y V_z \\rangle &amp; \\langle V_z^2 \\rangle \\end{bmatrix} \\]"},{"location":"getting-technical/structure_tensor/#eigen-decomposition","title":"Eigen Decomposition","text":"<p>Each structure tensor \\(S\\) is decomposed into eigenvalues \\(\\lambda_1 \\leq \\lambda_2 \\leq \\lambda_3\\) and corresponding eigenvectors \\(\\vec{v}_1, \\vec{v}_2, \\vec{v}_3\\).</p> <ul> <li>\\(\\vec{v}_1\\): direction with least intensity change (principal fiber direction)</li> <li>\\(\\vec{v}_3\\): direction of greatest intensity change</li> </ul>"},{"location":"getting-technical/structure_tensor/#output-and-interpretation","title":"Output and Interpretation","text":"<ul> <li>The third eigenvector \\(\\vec{v}_1\\) is stored as the local myocyte orientation.</li> <li>Helix and intrusion angles are computed from \\(\\vec{v}_1\\) after transforming it into cylindrical coordinates.</li> <li>Fractional Anisotropy (FA) is computed using the three eigenvalues (see FA section).</li> </ul>"},{"location":"getting-technical/structure_tensor/#parameters","title":"Parameters","text":"<ul> <li>\\(\\sigma\\) (noise scale): Controls how much local variation is smoothed in gradient calculation.</li> <li>\\(\\rho\\) (integration scale): Defines the neighborhood size for averaging the tensor field.</li> </ul> <p>Higher \\(\\sigma\\) and \\(\\rho\\) values increase robustness to noise but reduce spatial precision.</p>"},{"location":"getting-technical/tractography/","title":"Tractography","text":"<p>This page describes the streamline tractography module in <code>cardiotensor</code>, used to trace paths through 3D vector fields of myocardial orientation.</p> <p>Streamlines represent the continuous direction of cardiomyocyte organization by following the principal eigenvector of the structure tensor field. This process is adapted from diffusion MRI tractography and tailored for cardiac microstructure.</p>"},{"location":"getting-technical/tractography/#overview","title":"Overview","text":"<p>The tractography module uses:</p> <ul> <li>FA thresholding to restrict tracing to well-aligned regions</li> <li>3D vector field integration to follow fiber orientation</li> <li>Curvature and boundary criteria to terminate streamlines</li> <li>Optional binning for speed and scalability</li> </ul> <p>Streamlines are computed using Runge-Kutta 4th order integration of the vector field.</p>"},{"location":"getting-technical/tractography/#algorithm","title":"Algorithm","text":""},{"location":"getting-technical/tractography/#seeding","title":"Seeding","text":"<p>Streamline seeds are placed randomly within a binary mask, typically derived from the FA map:</p> <ul> <li>Seed points are voxel coordinates where FA exceeds a threshold (e.g., 0.4).</li> <li>A fixed number of seeds (default: 20,000) are sampled randomly.</li> <li>The number and location of seeds can be configured using CLI.</li> </ul>"},{"location":"getting-technical/tractography/#integration","title":"Integration","text":"<p>Each streamline is computed using Runge-Kutta 4 (RK4) integration through the vector field.</p> <ul> <li>Input vector field must be of shape <code>(3, Z, Y, X)</code>, where the first dimension is (x, y, z) components.</li> <li>Step size is defined in voxel units (default: 0.5).</li> <li>Streamlines are traced bidirectionally from the seed (forward and backward).</li> </ul>"},{"location":"getting-technical/tractography/#termination-criteria","title":"Termination Criteria","text":"<p>Tracing stops when:</p> <ul> <li>FA falls below the user-defined threshold (default: 0.1)</li> <li>Turning angle between steps exceeds a threshold (default: 60\u00b0)</li> <li>The streamline exits image bounds</li> </ul>"},{"location":"getting-technical/tractography/#filtering","title":"Filtering","text":"<p>Streamlines shorter than <code>min_length_pts</code> (default: 10 points) are discarded. You can also post-filter based on curvature or anatomical ROIs.</p>"},{"location":"getting-technical/tractography/#output","title":"Output","text":"<p>The streamline results are saved in <code>.trk</code> format as:</p> <ul> <li><code>streamlines</code>: a list of arrays, each of shape (N, 3), where N is the number of points in that streamline</li> <li><code>ha_values</code>: sampled HA (helix angle) values along each point</li> </ul> <p>These can be loaded in Python or exported to <code>.vtk</code> for 3D visualization in ParaView.</p>"},{"location":"getting-technical/tractography/#example-command","title":"Example Command","text":"<pre><code>cardio-generate config.conf --seeds 20000 --bin 2 --step 0.5 --fa-threshold 0.15 --angle 60 --min_len 10\n</code></pre>"},{"location":"getting-technical/tractography/#notes","title":"Notes","text":"<ul> <li>Streamlines are computed from the 3rd eigenvector of the structure tensor, corresponding to the myocyte axis.</li> <li>FA is computed once from the structure tensor and optionally downsampled for speed.</li> <li>Helix angle (HA) is sampled at each point along the streamline and saved for further analysis.</li> </ul>"},{"location":"getting-technical/tractography/#advanced","title":"Advanced","text":"<ul> <li>Trilinear interpolation is used to ensure sub-voxel accuracy during integration.</li> <li>RK4 integration ensures smoother trajectories compared to simpler Euler methods.</li> <li>The code is optimized for parallel execution and can scale to large volumes (e.g., 8000\u00b3 voxels).</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides information about specific parts of cardiotensor:</p> <ul> <li>CLI Commands: A reference for cardiotensor's command line interface.</li> <li>Configuration file: A reference for cardiotensor's configuration file.</li> <li>API: A reference for cardiotensor's modules and functions.</li> </ul>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#cardiotensor","title":"cardiotensor","text":"<p>Modules:</p> <ul> <li> <code>analysis</code>           \u2013            </li> <li> <code>launcher</code>           \u2013            </li> <li> <code>orientation</code>           \u2013            </li> <li> <code>tractography</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis","title":"analysis","text":"<p>Modules:</p> <ul> <li> <code>analysis_functions</code>           \u2013            </li> <li> <code>gui_analysis_tool</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions","title":"analysis_functions","text":"<p>Functions:</p> <ul> <li> <code>calculate_intensities</code>             \u2013              <p>Calculate intensity profiles along multiple lines.</p> </li> <li> <code>find_end_points</code>             \u2013              <p>Find the end points for lines at different angles within a range.</p> </li> <li> <code>plot_intensity</code>             \u2013              <p>Plot intensity profiles with mean and percentile shading.</p> </li> <li> <code>save_intensity</code>             \u2013              <p>Save intensity profiles to a CSV file.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.calculate_intensities","title":"calculate_intensities","text":"<pre><code>calculate_intensities(img_helix: ndarray, start_point: tuple[int, int], end_point: tuple[int, int], angle_range: float = 5, N_line: int = 10, max_value: float | None = None, min_value: float | None = None) -&gt; list[ndarray]\n</code></pre> <p>Calculate intensity profiles along multiple lines.</p> <p>Parameters: img_helix (np.ndarray): The image array. start_point (Tuple[int, int]): The starting point of the line. end_point (Tuple[int, int]): The ending point of the line. angle_range (float, optional): The range of angles to consider in degrees. Default is 5. N_line (int, optional): The number of lines to generate. Default is 10. max_value (Optional[float], optional): Maximum value for intensity normalization. Default is None. min_value (Optional[float], optional): Minimum value for intensity normalization. Default is None.</p> <p>Returns: List[np.ndarray]: List of intensity profiles for each line.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.find_end_points","title":"find_end_points","text":"<pre><code>find_end_points(start_point: tuple[float, float], end_point: tuple[float, float], angle_range: float, N_line: int) -&gt; ndarray\n</code></pre> <p>Find the end points for lines at different angles within a range.</p> <p>Parameters: start_point (Tuple[int, int]): The starting point of the main line. end_point (Tuple[int, int]): The ending point of the main line. angle_range (float): The range of angles to consider in degrees. N_line (int): The number of lines to generate within the range.</p> <p>Returns: np.ndarray: Array of end points for the generated lines.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.plot_intensity","title":"plot_intensity","text":"<pre><code>plot_intensity(intensity_profiles: list[ndarray], label_y: str = '', x_max_lim: float | None = None, x_min_lim: float | None = None, y_max_lim: float | None = None, y_min_lim: float | None = None) -&gt; None\n</code></pre> <p>Plot intensity profiles with mean and percentile shading.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. label_y (str, optional): Label for the y-axis. Default is an empty string. x_max_lim (Optional[float], optional): Maximum x-axis limit. Default is None. x_min_lim (Optional[float], optional): Minimum x-axis limit. Default is None. y_max_lim (Optional[float], optional): Maximum y-axis limit. Default is None. y_min_lim (Optional[float], optional): Minimum y-axis limit. Default is None.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.save_intensity","title":"save_intensity","text":"<pre><code>save_intensity(intensity_profiles: list[ndarray], save_path: str) -&gt; None\n</code></pre> <p>Save intensity profiles to a CSV file.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. save_path (str): Path to save the CSV file.</p> <p>Returns: None</p>"},{"location":"reference/api/#cardiotensor.analysis.gui_analysis_tool","title":"gui_analysis_tool","text":"<p>Functions:</p> <ul> <li> <code>convert_slice_for_display</code>             \u2013              <p>Return normalized float slice for display, in the mode's physical domain, then min-max to 0..1.</p> </li> <li> <code>discover_modes</code>             \u2013              <p>Return list of available subfolders among HA, IA, AZ, EL, FA, in a stable order.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.gui_analysis_tool.convert_slice_for_display","title":"convert_slice_for_display","text":"<pre><code>convert_slice_for_display(slice2d: ndarray, mode: str) -&gt; ndarray\n</code></pre> <p>Return normalized float slice for display, in the mode's physical domain, then min-max to 0..1.</p>"},{"location":"reference/api/#cardiotensor.analysis.gui_analysis_tool.discover_modes","title":"discover_modes","text":"<pre><code>discover_modes(base: Path) -&gt; list[str]\n</code></pre> <p>Return list of available subfolders among HA, IA, AZ, EL, FA, in a stable order.</p>"},{"location":"reference/api/#cardiotensor.launcher","title":"launcher","text":"<p>Modules:</p> <ul> <li> <code>slurm_launcher</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher","title":"slurm_launcher","text":"<p>Functions:</p> <ul> <li> <code>is_chunk_done</code>             \u2013              <p>Check if all output files (HA, IA, FA) for a given chunk are already present.</p> </li> <li> <code>monitor_job_output</code>             \u2013              <p>Monitor OUTPUT_DIR/HA until total_images files appear (subset-aware).</p> </li> <li> <code>slurm_launcher</code>             \u2013              <p>Launch Slurm array jobs for a subset [start_index, end_index] (inclusive) of the volume.</p> </li> <li> <code>submit_job_to_slurm</code>             \u2013              <p>Submit a Slurm job and return its job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done","title":"is_chunk_done","text":"<pre><code>is_chunk_done(output_dir: str, start: int, end: int, output_format: str = 'jp2') -&gt; bool\n</code></pre> <p>Check if all output files (HA, IA, FA) for a given chunk are already present.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if all expected output files exist, False otherwise.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>)           \u2013            <p>Base output directory containing HA/IA/FA folders.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(start)","title":"<code>start</code>","text":"(<code>int</code>)           \u2013            <p>Start index of the chunk (inclusive).</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(end)","title":"<code>end</code>","text":"(<code>int</code>)           \u2013            <p>End index of the chunk (exclusive).</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(output_format)","title":"<code>output_format</code>","text":"(<code>str</code>, default:                   <code>'jp2'</code> )           \u2013            <p>File extension for the output images (e.g., \"jp2\", \"tif\").</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output","title":"monitor_job_output","text":"<pre><code>monitor_job_output(output_directory: str, total_images: int, file_extension: str) -&gt; None\n</code></pre> <p>Monitor OUTPUT_DIR/HA until total_images files appear (subset-aware).</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.slurm_launcher","title":"slurm_launcher","text":"<pre><code>slurm_launcher(conf_file_path: str, start_index: int = 0, end_index: int | None = None) -&gt; None\n</code></pre> <p>Launch Slurm array jobs for a subset [start_index, end_index] (inclusive) of the volume. If end_index is None, the last slice of the volume is used.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm","title":"submit_job_to_slurm","text":"<pre><code>submit_job_to_slurm(executable_path: str, conf_file_path: str, start_image: int, end_image: int, N_chunk: int = 10, mem_needed: int = 64) -&gt; int\n</code></pre> <p>Submit a Slurm job and return its job ID.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The Slurm job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(executable_path)","title":"<code>executable_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the executable script.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(start_image)","title":"<code>start_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the first image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(end_image)","title":"<code>end_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the last image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(N_chunk)","title":"<code>N_chunk</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of chunks for the job. Default is 10.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(mem_needed)","title":"<code>mem_needed</code>","text":"(<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Memory required in GB. Default is 64.</p>"},{"location":"reference/api/#cardiotensor.orientation","title":"orientation","text":"<p>Modules:</p> <ul> <li> <code>orientation_computation_functions</code>           \u2013            </li> <li> <code>orientation_computation_pipeline</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions","title":"orientation_computation_functions","text":"<p>Functions:</p> <ul> <li> <code>adjust_start_end_index</code>             \u2013              <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> </li> <li> <code>calculate_center_vector</code>             \u2013              <p>Compute the linear regression vector for a given set of 3D points.</p> </li> <li> <code>calculate_structure_tensor</code>             \u2013              <p>Calculates the structure tensor of a volume.</p> </li> <li> <code>compute_azimuth_and_elevation</code>             \u2013              <p>Azimuth = angle in XY plane from +X toward +Y, in degrees [-180, 180]</p> </li> <li> <code>compute_fraction_anisotropy</code>             \u2013              <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> </li> <li> <code>compute_helix_and_transverse_angles</code>             \u2013              <p>Computes helix and transverse angles from a 2D vector field.</p> </li> <li> <code>interpolate_points</code>             \u2013              <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> </li> <li> <code>plot_images</code>             \u2013              <p>Render a 2x2 figure of source, angle1, angle2, FA for a single slice.</p> </li> <li> <code>remove_padding</code>             \u2013              <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> </li> <li> <code>rotate_vectors_to_new_axis</code>             \u2013              <p>Rotates a vector field slice to align with a new axis.</p> </li> <li> <code>write_images</code>             \u2013              <p>Write per-slice angle1, angle2, and FA images to disk with flexible naming and ranges.</p> </li> <li> <code>write_img_rgb</code>             \u2013              <p>Write a single 2D float image as an RGB file using a matplotlib colormap.</p> </li> <li> <code>write_vector_field</code>             \u2013              <p>Saves a vector field slice to the specified directory in .npy format.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index","title":"adjust_start_end_index","text":"<pre><code>adjust_start_end_index(start_index: int, end_index: int, N_img: int, padding_start: int = 0, padding_end: int = 0, is_test: bool = False, n_slice: int = 0) -&gt; tuple[int, int]\n</code></pre> <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>Tuple[int, int]: Adjusted start and end indices.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial start index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial end index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>Number of images in the volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Padding to add at the start.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Padding to add at the end.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(is_test)","title":"<code>is_test</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating whether in test mode.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(n_slice)","title":"<code>n_slice</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Test slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector","title":"calculate_center_vector","text":"<pre><code>calculate_center_vector(points: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the linear regression vector for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: A single 3D unit vector representing the direction of the best-fit line.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An Nx3 array of (x, y, z) coordinates representing the curved line.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor","title":"calculate_structure_tensor","text":"<pre><code>calculate_structure_tensor(volume: ndarray, sigma: float, rho: float, truncate: float = 4.0, devices: list[str] | None = None, block_size: int = 200, use_gpu: bool = False, dtype: type = float32) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Calculates the structure tensor of a volume.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>tuple[np.ndarray, np.ndarray]: Eigenvalues and eigenvectors of the structure tensor.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(sigma)","title":"<code>sigma</code>","text":"(<code>float</code>)           \u2013            <p>sigma value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(rho)","title":"<code>rho</code>","text":"(<code>float</code>)           \u2013            <p>rho value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(devices)","title":"<code>devices</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of devices for parallel processing (e.g., ['cpu', 'cuda:0']).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(block_size)","title":"<code>block_size</code>","text":"(<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Size of the blocks for processing. Default is 200.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses GPU for calculations. Default is False.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_azimuth_and_elevation","title":"compute_azimuth_and_elevation","text":"<pre><code>compute_azimuth_and_elevation(vector_field_2d: ndarray) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Azimuth = angle in XY plane from +X toward +Y, in degrees [-180, 180] Elevation = angle from XY plane toward +Z, in degrees [-90, 90]</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy","title":"compute_fraction_anisotropy","text":"<pre><code>compute_fraction_anisotropy(eigenvalues_2d: ndarray) -&gt; ndarray\n</code></pre> <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Fractional Anisotropy values.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy(eigenvalues_2d)","title":"<code>eigenvalues_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of eigenvalues (l1, l2, l3).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles","title":"compute_helix_and_transverse_angles","text":"<pre><code>compute_helix_and_transverse_angles(vector_field_2d: ndarray, center_point: tuple[int, int, int]) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Computes helix and transverse angles from a 2D vector field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray]: Helix and transverse angle arrays.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(vector_field_2d)","title":"<code>vector_field_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D orientation vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(center_point)","title":"<code>center_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Coordinates of the center point.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points","title":"interpolate_points","text":"<pre><code>interpolate_points(points: list[tuple[float, float, float]], N_img: int) -&gt; ndarray\n</code></pre> <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of interpolated points.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(points)","title":"<code>points</code>","text":"(<code>list[tuple[float, float, float]]</code>)           \u2013            <p>A list of (x, y, z) points.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>The number of slices in the z-dimension.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images","title":"plot_images","text":"<pre><code>plot_images(img: ndarray, img_angle1: ndarray, img_angle2: ndarray, img_FA: ndarray, center_point: tuple[int, int, int], colormap_angle=None, colormap_FA=None, angle1_title: str = 'Helix Angle', angle2_title: str = 'Intrusion Angle') -&gt; None\n</code></pre> <p>Render a 2x2 figure of source, angle1, angle2, FA for a single slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images--parameters","title":"Parameters","text":"<p>img : np.ndarray     2D grayscale slice of the anatomical image. img_angle1 : np.ndarray     2D float map for the first angle, for example HA or AZ, in degrees. img_angle2 : np.ndarray     2D float map for the second angle, for example IA or EL, in degrees. img_FA : np.ndarray     2D float map of fractional anisotropy in [0, 1]. center_point : tuple[int, int, int]     Integer voxel coordinates (z, y, x) of the centerline point on this slice.     Only (y, x) is used here for the marker. colormap_angle : matplotlib colormap, optional     Colormap for angles. Defaults to plt.cm.hsv if None. colormap_FA : matplotlib colormap, optional     Colormap for FA. Defaults to plt.cm.magma if None. angle1_title : str     Title for the first angle panel. angle2_title : str     Title for the second angle panel.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images--notes","title":"Notes","text":"<p>This function shows the centerline marker on the source panel.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding","title":"remove_padding","text":"<pre><code>remove_padding(volume: ndarray, val: ndarray, vec: ndarray, padding_start: int, padding_end: int) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Adjusted data without padding.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(val)","title":"<code>val</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvalues.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(vec)","title":"<code>vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvectors.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the start to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the end to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis","title":"rotate_vectors_to_new_axis","text":"<pre><code>rotate_vectors_to_new_axis(vector_field_slice: ndarray, new_axis_vec: ndarray) -&gt; ndarray\n</code></pre> <p>Rotates a vector field slice to align with a new axis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotated vectors with the same shape as input.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of shape (3, Y, X) for a slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(new_axis_vec)","title":"<code>new_axis_vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The new axis to align vectors with (3,).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images","title":"write_images","text":"<pre><code>write_images(img_angle1: ndarray, img_angle2: ndarray, img_FA: ndarray, start_index: int, output_dir: str, output_format: str, output_type: str, z: int, colormap_angle=None, colormap_FA=None, angle_names: tuple[str, str] = ('HA', 'IA'), angle_ranges: tuple[tuple[float, float], tuple[float, float]] = ((-90, 90), (-90, 90))) -&gt; None\n</code></pre> <p>Write per-slice angle1, angle2, and FA images to disk with flexible naming and ranges.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images--parameters","title":"Parameters","text":"<p>img_angle1 : np.ndarray     2D float array for the first angle, for example HA or AZ, in degrees. img_angle2 : np.ndarray     2D float array for the second angle, for example IA or EL, in degrees. img_FA : np.ndarray     2D float array for FA in [0, 1]. start_index : int     Global starting index for z numbering in filenames. output_dir : str     Base output directory. Subfolders angle_names[0], angle_names[1], and FA are created. output_format : {\"jp2\", \"tif\"}     Output file format. Uses glymur for jp2 and tifffile for tif. output_type : {\"8bit\", \"rgb\"}     Write mode. \"8bit\" writes single channel uint8, \"rgb\" writes colormapped RGB. z : int     Current z offset used to compute the running index in filenames. colormap_angle : matplotlib colormap, optional     Colormap for angles in \"rgb\" mode. Defaults to plt.cm.hsv if None. colormap_FA : matplotlib colormap, optional     Colormap for FA in \"rgb\" mode. Defaults to plt.cm.magma if None. angle_names : tuple[str, str]     Names used for subfolders and file prefixes, for example (\"HA\", \"IA\") or (\"AZ\", \"EL\"). angle_ranges : tuple[(float, float), (float, float)]     Min and max for normalization of angle1 and angle2. For example     HA and IA use (-90, 90), AZ uses (-180, 180) and EL uses (-90, 90).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images--raises","title":"Raises","text":"<p>RuntimeError     If required IO backends are missing for the chosen format. ValueError     If output_format or output_type is unsupported.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images--notes","title":"Notes","text":"<p>The function creates subdirectories and writes files named like: {output_dir}/{name}/{name}{index:06d}.{ext} and {output_dir}/FA/FA}.{ext</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_img_rgb","title":"write_img_rgb","text":"<pre><code>write_img_rgb(img: ndarray, out_path: str, vmin: float, vmax: float, colormap: object | None = None, output_format: str = 'jp2') -&gt; None\n</code></pre> <p>Write a single 2D float image as an RGB file using a matplotlib colormap.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_img_rgb--parameters","title":"Parameters","text":"<p>img : np.ndarray     2D float array to color map. out_path : str     Full output path without extension handling. vmin : float     Minimum for normalization. vmax : float     Maximum for normalization. colormap : matplotlib colormap, optional     Colormap to apply, for example plt.cm.hsv. If None, use plt.cm.hsv. output_format : {\"jp2\", \"tif\"}     Output format. Uses glymur for jp2 and tifffile for tif.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_img_rgb--notes","title":"Notes","text":"<p>The function normalizes to [0, 1], applies the colormap, then writes uint8 RGB.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field","title":"write_vector_field","text":"<pre><code>write_vector_field(vector_field_slice: ndarray, start_index: int, output_dir: str, slice_idx: int) -&gt; None\n</code></pre> <p>Saves a vector field slice to the specified directory in .npy format.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field data slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Starting index for filenames.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(slice_idx)","title":"<code>slice_idx</code>","text":"(<code>int</code>)           \u2013            <p>Current slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline","title":"orientation_computation_pipeline","text":"<p>Functions:</p> <ul> <li> <code>check_already_processed</code>             \u2013              <p>Check whether all required output files already exist for every slice index.</p> </li> <li> <code>compute_orientation</code>             \u2013              <p>Compute the orientation for a volume dataset.</p> </li> <li> <code>compute_slice_angles_and_anisotropy</code>             \u2013              <p>Compute either HA/IA or Azimuth/Elevation plus FA for a single slice,</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.check_already_processed","title":"check_already_processed","text":"<pre><code>check_already_processed(output_dir: str, start_index: int, end_index: int, write_vectors: bool, write_angles: bool, output_format: str, angle_names: tuple[str, str] = ('HA', 'IA'), fa_name: str = 'FA', extra_expected: Sequence[str] | None = None) -&gt; bool\n</code></pre> <p>Check whether all required output files already exist for every slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.check_already_processed--parameters","title":"Parameters","text":"<p>output_dir : str     Base output directory. start_index : int     First global slice index to check (inclusive). end_index : int     Last global slice index to check (exclusive). write_vectors : bool     If True, expect eigenvector .npy files (e.g., eigen_vec_{idx:06d}.npy). write_angles : bool     If True, expect angle images for angle_names[0], angle_names[1], and FA. output_format : str     Image format/extension for angles, for example \"jp2\" or \"tif\". angle_names : tuple[str, str], optional     Names of the two angle outputs, e.g. (\"HA\", \"IA\") or (\"AZ\", \"EL\"). fa_name : str, optional     Name of the FA subfolder, default \"FA\". extra_expected : sequence of str, optional     Additional per-slice path templates to check. Each template must contain     \"{idx}\" which will be formatted as a zero-padded integer (06d), and may     also contain \"{ext}\" for the image extension.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.check_already_processed--returns","title":"Returns","text":"<p>bool     True if all expected files for all indices exist (and pass the quick     corruption filter), False otherwise.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation","title":"compute_orientation","text":"<pre><code>compute_orientation(volume_path: str, mask_path: str | None = None, output_dir: str = './output', output_format: str = 'jp2', output_type: str = '8bit', sigma: float = 1.0, rho: float = 3.0, truncate: float = 4.0, axis_points: ndarray | None = None, vertical_padding: float | None = None, write_vectors: bool = False, angle_mode: str = 'ha_ia', write_angles: bool = True, use_gpu: bool = True, is_test: bool = False, n_slice_test: int | None = None, start_index: int = 0, end_index: int | None = None) -&gt; None\n</code></pre> <p>Compute the orientation for a volume dataset.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(volume_path)","title":"<code>volume_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the 3D volume.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(mask_path)","title":"<code>mask_path</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional binary mask path.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>, default:                   <code>'./output'</code> )           \u2013            <p>Output directory for results.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(output_format)","title":"<code>output_format</code>","text":"(<code>str</code>, default:                   <code>'jp2'</code> )           \u2013            <p>Image format for results.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(output_type)","title":"<code>output_type</code>","text":"(<code>str</code>, default:                   <code>'8bit'</code> )           \u2013            <p>Image type (\"8bit\" or \"rgb\").</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(sigma)","title":"<code>sigma</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Noise scale for structure tensor.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(rho)","title":"<code>rho</code>","text":"(<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>Integration scale for structure tensor.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(truncate)","title":"<code>truncate</code>","text":"(<code>float</code>, default:                   <code>4.0</code> )           \u2013            <p>Gaussian kernel truncation.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(axis_points)","title":"<code>axis_points</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>3D points defining LV axis for cylindrical coordinates.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(vertical_padding)","title":"<code>vertical_padding</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Padding slices for tensor computation.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(write_vectors)","title":"<code>write_vectors</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to save eigenvectors.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(write_angles)","title":"<code>write_angles</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to save HA/IA/FA maps.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use GPU acceleration for tensor computation.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(is_test)","title":"<code>is_test</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, runs in test mode and outputs plots.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(n_slice_test)","title":"<code>n_slice_test</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of slices to process in test mode.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(end_index)","title":"<code>end_index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>End slice index (None = last slice).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy","title":"compute_slice_angles_and_anisotropy","text":"<pre><code>compute_slice_angles_and_anisotropy(z: int, vector_field_slice: ndarray, img_slice: ndarray, center_point: ndarray, eigen_val_slice: ndarray, center_line: ndarray, output_dir: str, output_format: str = 'jp2', output_type: str = '8bit', start_index: int = 0, write_vectors: bool = False, write_angles: bool = True, is_test: bool = False, angle_mode: str = 'ha_ia') -&gt; None\n</code></pre> <p>Compute either HA/IA or Azimuth/Elevation plus FA for a single slice, then plot and/or write outputs depending on flags.</p>"},{"location":"reference/api/#cardiotensor.tractography","title":"tractography","text":"<p>Modules:</p> <ul> <li> <code>generate_streamlines</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines","title":"generate_streamlines","text":"<p>Functions:</p> <ul> <li> <code>generate_streamlines_from_params</code>             \u2013              <p>Generate streamlines from the eigenvector field, then export:</p> </li> <li> <code>save_trk_dipy_from_vox_zyx</code>             \u2013              <p>Save streamlines given in voxel indices (z,y,x) as TrackVis .trk using DIPY.</p> </li> <li> <code>save_trk_dipy_from_vox_zyx_multi</code>             \u2013              <p>Save streamlines in voxel indices (z,y,x) as TrackVis .trk using DIPY.</p> </li> <li> <code>trilinear_interpolate_scalar</code>             \u2013              <p>Trilinearly interpolate a scalar volume at fractional point (z, y, x).</p> </li> <li> <code>trilinear_interpolate_vector</code>             \u2013              <p>Given a fractional (z,y,x), returns the trilinearly\u2010interpolated 3\u2010vector</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.generate_streamlines_from_params","title":"generate_streamlines_from_params","text":"<pre><code>generate_streamlines_from_params(vector_field_dir: str | Path, output_dir: str | Path, fa_dir: str | Path, angle_dir: str | Path, mask_path: str | Path | None = None, start_xyz: tuple[int, int, int] = (0, 0, 0), end_xyz: tuple[int | None, int | None, int | None] = (None, None, None), bin_factor: int = 1, num_seeds: int = 20000, fa_seed_min: float = 0.4, fa_threshold: float = 0.1, step_length: float = 0.5, max_steps: int | None = None, angle_threshold: float = 60.0, min_length_pts: int = 10, bidirectional: bool = True, voxel_sizes_zyx: tuple[float, float, float] = (1.0, 1.0, 1.0), save_trk_file: bool = True) -&gt; None\n</code></pre> <p>Generate streamlines from the eigenvector field, then export:   - .trk with all discovered per-point angle fields   - .am with all per-edge mean angle scalars</p> Angle discovery <p>If <code>angle_dir</code> is one of HA, IA, AZ, EL, discover siblings with those names and include all that exist. If <code>angle_dir</code> is a parent, include all subfolders named HA, IA, AZ, EL that exist. If none are found, treat <code>angle_dir</code> as a single custom angle and include it.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.save_trk_dipy_from_vox_zyx","title":"save_trk_dipy_from_vox_zyx","text":"<pre><code>save_trk_dipy_from_vox_zyx(streamlines_zyx: list[list[tuple[float, float, float]]], out_path: str | Path, vol_shape_zyx: tuple[int, int, int], voxel_sizes_zyx: tuple[float, float, float] = (1.0, 1.0, 1.0), data_values: list[ndarray] | None = None, data_name: str | None = None)\n</code></pre> <p>Save streamlines given in voxel indices (z,y,x) as TrackVis .trk using DIPY. Optionally attach one per-point scalar list under <code>data_name</code>.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.save_trk_dipy_from_vox_zyx_multi","title":"save_trk_dipy_from_vox_zyx_multi","text":"<pre><code>save_trk_dipy_from_vox_zyx_multi(streamlines_zyx: list[list[tuple[float, float, float]]], out_path: str | Path, vol_shape_zyx: tuple[int, int, int], voxel_sizes_zyx: tuple[float, float, float] = (1.0, 1.0, 1.0), data_per_point: dict[str, list[ndarray]] | None = None) -&gt; None\n</code></pre> <p>Save streamlines in voxel indices (z,y,x) as TrackVis .trk using DIPY. Accepts multiple per-point scalar lists via <code>data_per_point</code> dict, with keys like \"HA\", \"IA\", \"AZ\", \"EL\". Each list must align with streamlines.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.trilinear_interpolate_scalar","title":"trilinear_interpolate_scalar","text":"<pre><code>trilinear_interpolate_scalar(volume: ndarray, pt: tuple[float, float, float]) -&gt; float\n</code></pre> <p>Trilinearly interpolate a scalar volume at fractional point (z, y, x). Clamps to valid range.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.trilinear_interpolate_vector","title":"trilinear_interpolate_vector","text":"<pre><code>trilinear_interpolate_vector(vector_field: ndarray, pt: tuple[float, float, float]) -&gt; ndarray\n</code></pre> <p>Given a fractional (z,y,x), returns the trilinearly\u2010interpolated 3\u2010vector from <code>vector_field</code> (shape = (3, Z, Y, X)). Clamps to nearest voxel if out\u2010of\u2010bounds.</p>"},{"location":"reference/api/#cardiotensor.utils","title":"utils","text":"<p>Modules:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> <li> <code>am_utils</code>           \u2013            </li> <li> <code>downsampling</code>           \u2013            </li> <li> <code>streamlines_io_utils</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader","title":"DataReader","text":"<p>Classes:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader","title":"DataReader","text":"<pre><code>DataReader(path: str | Path)\n</code></pre> <p>Initializes the DataReader with a path to the volume.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>check_memory_requirement</code>             \u2013              <p>Check if the dataset can fit in available memory.</p> </li> <li> <code>load_volume</code>             \u2013              <p>Loads the volume and resizes it to unbinned_shape if provided, using fast</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Returns the data type of the volume.</p> </li> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>Returns the shape of the volume as (Z, Y, X) or (Z, Y, X, C).</p> </li> <li> <code>volume_size_gb</code>               (<code>float</code>)           \u2013            <p>Returns the total size of the volume in GB.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to the volume directory or file.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Returns the data type of the volume.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Returns the shape of the volume as (Z, Y, X) or (Z, Y, X, C).</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.volume_size_gb","title":"volume_size_gb  <code>property</code>","text":"<pre><code>volume_size_gb: float\n</code></pre> <p>Returns the total size of the volume in GB.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.check_memory_requirement","title":"check_memory_requirement","text":"<pre><code>check_memory_requirement(shape, dtype, safety_factor=0.8)\n</code></pre> <p>Check if the dataset can fit in available memory.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.check_memory_requirement(shape)","title":"<code>shape</code>","text":"(<code>tuple[int]</code>)           \u2013            <p>Shape of the array.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.check_memory_requirement(dtype)","title":"<code>dtype</code>","text":"(<code>dtype</code>)           \u2013            <p>NumPy dtype of the array.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.check_memory_requirement(safety_factor)","title":"<code>safety_factor</code>","text":"(<code>float</code>, default:                   <code>0.8</code> )           \u2013            <p>Fraction of available memory allowed to be used.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume","title":"load_volume","text":"<pre><code>load_volume(start_index: int = 0, end_index: int | None = None, unbinned_shape: tuple[int, int, int] | None = None) -&gt; ndarray\n</code></pre> <p>Loads the volume and resizes it to unbinned_shape if provided, using fast integer-only resampling: - np.repeat for upsampling - block_reduce (max) for downsampling</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Loaded volume.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start index for slicing (for stacks).</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>End index for slicing (for stacks). If None, loads the entire stack.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(unbinned_shape)","title":"<code>unbinned_shape</code>","text":"(<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>Desired shape (Z, Y, X). If None, no resizing is done.</p>"},{"location":"reference/api/#cardiotensor.utils.am_utils","title":"am_utils","text":"<p>Functions:</p> <ul> <li> <code>write_spatialgraph_am</code>             \u2013              <p>Minimal Amira SpatialGraph writer with optional EDGE scalar blocks.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.am_utils.write_spatialgraph_am","title":"write_spatialgraph_am","text":"<pre><code>write_spatialgraph_am(out_path: str | Path, streamlines_xyz: list[ndarray], point_thickness: Sequence[ndarray] | ndarray | None = None, edge_scalar: Sequence[float] | ndarray | Mapping[str, Sequence[float] | ndarray] | None = None, edge_scalar_name: str | None = None) -&gt; None\n</code></pre> <p>Minimal Amira SpatialGraph writer with optional EDGE scalar blocks.</p> Writes blocks <p>@1 VERTEX float[3] @2 EDGE   int[2] @3 EDGE   int          NumEdgePoints @4 POINT  float[3]     EdgePointCoordinates @5 POINT  float        thickness @6..     EDGE  float    one or more per-edge scalars"},{"location":"reference/api/#cardiotensor.utils.am_utils.write_spatialgraph_am--parameters","title":"Parameters","text":"<p>out_path : str | Path     Output .am path. streamlines_xyz : list[np.ndarray]     List of polylines (x, y, z). Each array shape = (Ni, 3), Ni &gt;= 2. point_thickness : np.ndarray | list[np.ndarray], optional     Per-point thickness. Either a flat array of length sum(Ni) or a list     aligned to streamlines with lengths Ni. edge_scalar : array-like | dict[str, array-like], optional     - If a 1D array-like: one scalar per edge, use <code>edge_scalar_name</code>.     - If a dict: multiple scalars, each value must be 1D, length = n_edges.       Keys become field names. edge_scalar_name : str, optional     Name for the single-scalar case. If <code>edge_scalar</code> is a dict, this is ignored.</p>"},{"location":"reference/api/#cardiotensor.utils.am_utils.write_spatialgraph_am--notes","title":"Notes","text":"<ul> <li>Field names are lightly validated for Amira compatibility.</li> <li>Values are written as ASCII floats with 6 decimal places.</li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling","title":"downsampling","text":"<p>Functions:</p> <ul> <li> <code>chunked_downsample_vector_volume_mp</code>             \u2013              <p>Multi\u2010process + progress\u2010bar version of chunked_downsample_vector_volume.</p> </li> <li> <code>downsample_vector_volume</code>             \u2013              <p>Downsamples a vector volume using multiprocessing.</p> </li> <li> <code>downsample_volume</code>             \u2013              <p>Downsamples a 3D image volume along the Z and XY axes and saves as 8-bit images.</p> </li> <li> <code>process_image_block</code>             \u2013              <p>Process a Z-block of images by averaging along the Z axis,</p> </li> <li> <code>process_vector_block</code>             \u2013              <p>Processes a single block of numpy files and saves the downsampled output.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling.chunked_downsample_vector_volume_mp","title":"chunked_downsample_vector_volume_mp","text":"<pre><code>chunked_downsample_vector_volume_mp(input_npy_dir: Path, bin_factor: int, output_dir: Path) -&gt; None\n</code></pre> <p>Multi\u2010process + progress\u2010bar version of chunked_downsample_vector_volume. Reads a directory of per\u2010slice NumPy files (shape = (3, H, W) each), groups every <code>bin_factor</code> consecutive slices into blocks, averages, downsamples, renormalizes, and writes each block as one coarse slice in output_dir/bin{bin_factor}/eigen_vec/.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.chunked_downsample_vector_volume_mp--parameters","title":"Parameters","text":"<p>input_npy_dir : Path     Directory containing fine\u2010scale \u201ceigen_vec_*.npy\u201d files, each shape (3, H, W). bin_factor : int     Number of fine Z\u2010slices per block. output_dir : Path     Base output directory. Will create output_dir/bin{bin_factor}/eigen_vec/.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume","title":"downsample_vector_volume","text":"<pre><code>downsample_vector_volume(input_npy: Path, bin_factor: int, output_dir: Path) -&gt; None\n</code></pre> <p>Downsamples a vector volume using multiprocessing.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(input_npy)","title":"<code>input_npy</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing numpy files.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume","title":"downsample_volume","text":"<pre><code>downsample_volume(input_path: Path, bin_factor: int, output_dir: Path, subfolder: str = 'HA', out_ext: str = 'tif', min_value: float = 0, max_value: float = 255) -&gt; None\n</code></pre> <p>Downsamples a 3D image volume along the Z and XY axes and saves as 8-bit images.</p> <p>This function reads a volumetric image dataset (e.g. TIFF stack) using DataReader, performs block averaging along the Z-axis and spatial downsampling in XY, then saves each resulting slice in a specified output directory as 8-bit images.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(input_path)","title":"<code>input_path</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing the image stack.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Factor to downsample in XY and the number of Z-slices to average per output slice.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output root directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(subfolder)","title":"<code>subfolder</code>","text":"(<code>str</code>, default:                   <code>'HA'</code> )           \u2013            <p>Subdirectory name under <code>binX/</code> to place results (default: \"HA\").</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(out_ext)","title":"<code>out_ext</code>","text":"(<code>str</code>, default:                   <code>'tif'</code> )           \u2013            <p>Output image format extension (e.g., 'tif', 'png').</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(min_value)","title":"<code>min_value</code>","text":"(<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Minimum value for intensity normalization to 8-bit.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(max_value)","title":"<code>max_value</code>","text":"(<code>float</code>, default:                   <code>255</code> )           \u2013            <p>Maximum value for intensity normalization to 8-bit.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block","title":"process_image_block","text":"<pre><code>process_image_block(file_list, block_idx, bin_factor, out_file, min_value, max_value)\n</code></pre> <p>Process a Z-block of images by averaging along the Z axis, downsampling in XY, converting to 8-bit, and writing to disk.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(file_list)","title":"<code>file_list</code>","text":"(<code>list</code>)           \u2013            <p>List of file paths (entire volume stack).</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for XY downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(out_file)","title":"<code>out_file</code>","text":"(<code>Path</code>)           \u2013            <p>Output file path for the downsampled image.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(min_value)","title":"<code>min_value</code>","text":"(<code>float</code>)           \u2013            <p>Minimum intensity for 8-bit scaling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(max_value)","title":"<code>max_value</code>","text":"(<code>float</code>)           \u2013            <p>Maximum intensity for 8-bit scaling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block","title":"process_vector_block","text":"<pre><code>process_vector_block(block: list[Path], bin_factor: int, h: int, w: int, output_dir: Path, idx: int) -&gt; None\n</code></pre> <p>Processes a single block of numpy files and saves the downsampled output.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(block)","title":"<code>block</code>","text":"(<code>List[Path]</code>)           \u2013            <p>List of file paths to the numpy files in the block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(h)","title":"<code>h</code>","text":"(<code>int</code>)           \u2013            <p>Height of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(w)","title":"<code>w</code>","text":"(<code>int</code>)           \u2013            <p>Width of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(idx)","title":"<code>idx</code>","text":"(<code>int</code>)           \u2013            <p>Index of the current block.</p>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils","title":"streamlines_io_utils","text":"<p>Functions:</p> <ul> <li> <code>compute_elevation_angles</code>             \u2013              <p>Compute per-vertex elevation angle from streamline geometry:</p> </li> <li> <code>ha_to_degrees_per_streamline</code>             \u2013              <p>Convert HA values that might be byte-scaled (0..255) to degrees (-90..90).</p> </li> <li> <code>load_npz_streamlines</code>             \u2013              <p>Load streamlines from a .npz file saved as object arrays.</p> </li> <li> <code>load_trk_streamlines</code>             \u2013              <p>Load streamlines and all per-point fields from a TrackVis .trk file.</p> </li> <li> <code>normalize_attrs_to_degrees</code>             \u2013              <p>Normalize HA, IA, AZ, EL fields to degrees if stored as 0\u2013255.</p> </li> <li> <code>reduce_per_edge</code>             \u2013              <p>Reduce per-point values along each streamline to a single scalar per edge.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.compute_elevation_angles","title":"compute_elevation_angles","text":"<pre><code>compute_elevation_angles(streamlines_xyz: list[ndarray]) -&gt; list[ndarray]\n</code></pre> <p>Compute per-vertex elevation angle from streamline geometry: elevation = arcsin(z-component of unit tangent) in degrees. The last vertex copies the previous value to keep lengths aligned.</p>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.ha_to_degrees_per_streamline","title":"ha_to_degrees_per_streamline","text":"<pre><code>ha_to_degrees_per_streamline(ha_list: list[ndarray]) -&gt; list[ndarray]\n</code></pre> <p>Convert HA values that might be byte-scaled (0..255) to degrees (-90..90). Leaves values unchanged if they already look like degrees.</p>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.load_npz_streamlines","title":"load_npz_streamlines","text":"<pre><code>load_npz_streamlines(p: Path) -&gt; tuple[list[ndarray], dict[str, list[ndarray]]]\n</code></pre> <p>Load streamlines from a .npz file saved as object arrays. Expects 'streamlines' in (z, y, x). Converts to (x, y, z). Collects any per-point arrays whose keys end with '_values' and exposes them as uppercase names without the suffix, e.g. 'ha_values' -&gt; 'HA'.</p> <p>Returns:</p> <ul> <li> <code>streamlines_xyz</code> (              <code>list[ndarray]</code> )          \u2013            <p>list[np.ndarray], each (N_i, 3) in (x, y, z)</p> </li> <li> <code>per_point</code> (              <code>dict[str, list[ndarray]]</code> )          \u2013            <p>dict[str, list[np.ndarray]] keyed by field, each list aligned to streamlines</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.load_trk_streamlines","title":"load_trk_streamlines","text":"<pre><code>load_trk_streamlines(p: Path) -&gt; tuple[list[ndarray], dict[str, list[ndarray]]]\n</code></pre> <p>Load streamlines and all per-point fields from a TrackVis .trk file. Returns streamlines in (x, y, z) voxel/world space (as stored in the TRK), and a dict of per-point fields, one list per field aligned with streamlines.</p>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.normalize_attrs_to_degrees","title":"normalize_attrs_to_degrees","text":"<pre><code>normalize_attrs_to_degrees(attrs: dict | None) -&gt; dict[str, list[ndarray]]\n</code></pre> <p>Normalize HA, IA, AZ, EL fields to degrees if stored as 0\u2013255. If already in degrees or unit vectors, returns unchanged except cast to float32.</p> Input <p>attrs: dict[str, list[np.ndarray]] from TRK (e.g., {\"HA\":[...], \"IA\":[...], ...})</p> <p>Returns:</p> <ul> <li> <code>normalized</code> (              <code>dict[str, list[ndarray]]</code> )          \u2013            <p>same keys, each entry = list of np.ndarray (float32) in degrees.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.streamlines_io_utils.reduce_per_edge","title":"reduce_per_edge","text":"<pre><code>reduce_per_edge(values_per_point: list[ndarray], how: str = 'mean') -&gt; ndarray\n</code></pre> <p>Reduce per-point values along each streamline to a single scalar per edge.</p>"},{"location":"reference/api/#cardiotensor.utils.utils","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>convert_to_8bit</code>             \u2013              <p>Converts a NumPy array to an 8-bit image.</p> </li> <li> <code>read_conf_file</code>             \u2013              <p>Reads and parses a configuration file into a dictionary.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit","title":"convert_to_8bit","text":"<pre><code>convert_to_8bit(img: ndarray, perc_min: int = 0, perc_max: int = 100, min_value: float | None = None, max_value: float | None = None) -&gt; ndarray\n</code></pre> <p>Converts a NumPy array to an 8-bit image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 8-bit converted image.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>Input image array.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_min)","title":"<code>perc_min</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum percentile for normalization. Default is 0.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_max)","title":"<code>perc_max</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Maximum percentile for normalization. Default is 100.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(min_value)","title":"<code>min_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit minimum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(max_value)","title":"<code>max_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit maximum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file","title":"read_conf_file","text":"<pre><code>read_conf_file(file_path: str) -&gt; dict[str, Any]\n</code></pre> <p>Reads and parses a configuration file into a dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed configuration parameters.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the configuration file does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If expected numerical or array values are incorrectly formatted.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/cli/","title":"CLI Commands","text":"<p>Cardiotensor provides powerful features for analyzing 3D cardiac imaging data, from processing imaging volumes and calculating orientation to managing large-scale projects with support for multiple configurations and platforms.</p>"},{"location":"reference/cli/#orientation-computation","title":"Orientation Computation","text":"<p>Compute myocyte orientation from a 3D volume using a configuration file.</p> <ul> <li><code>cardio-tensor</code>   Computes structure tensor, helix/transverse angle, FA, and eigenvectors.</li> </ul> <p>See the example to get started.</p>"},{"location":"reference/cli/#transmural-analysis","title":"Transmural Analysis","text":"<p>Plot angle profiles across the heart wall using an interactive GUI.</p> <ul> <li><code>cardio-analysis</code>   Define transmural lines, adjust sampling, and export results.</li> </ul> <p>See the example for details.</p>"},{"location":"reference/cli/#3d-visualization","title":"3D Visualization","text":"<p>Visualize results in 3D using vector fields and streamlines.</p> <p>Note</p> <p>To use these modules, you must first compute and save the eigenvector field by setting <code>WRITE_VECTORS=True</code> in the configuration file before running the structure tensor calculation.</p> <ul> <li> <p><code>cardio-visualize-vector</code>   Render vector fields using Fury. Optionally export to ParaView (VTK format).</p> </li> <li> <p><code>cardio-generate-streamlines</code>   Generate streamlines from the vector field. Outputs <code>.trk</code> files compatible with Amira.</p> </li> <li> <p><code>cardio-visualize-streamlines</code>   Visualize streamlines in 3D using Fury. Can also export to ParaView.</p> </li> </ul> <p>See the example for usage.</p>"},{"location":"reference/cli/#next-steps","title":"Next Steps","text":"<p>Read the example for an introduction to each feature.</p>"},{"location":"reference/configuration/","title":"Configuration File","text":"<p>The configuration file in cardiotensor allows you to specify the parameters required for processing input datasets, calculating orientation tensors, computing angles, and saving results. Below is a detailed explanation of each section and parameter in the configuration file.</p>"},{"location":"reference/configuration/#example-configuration-file","title":"Example Configuration File","text":"<p>This is an example of a configuration file as found in the <code>examples/</code> directory.</p> <pre><code>[DATASET]\n# Path to the folder containing the input images (accepted formats: .tif, .jp2, .mhd)\nIMAGES_PATH = ./data/635.2um_LADAF-2021-17_heart_overview_\n\n# Voxel size of the input images in micrometers (\u00b5m).\nVOXEL_SIZE = 635.2\n\n# Path to the folder containing the segmentation mask (accepted formats: .tif or .jp2)\n# If no mask is available, leave this field empty.\nMASK_PATH = ./data/mask\n\n\n[STRUCTURE TENSOR CALCULATION]\n# Gradient scale (sigma) used for smoothing before gradient calculation.\n# This Gaussian filter reduces noise while preserving important edges.\nSIGMA = 0.4\n\n# Integration scale (rho) used for smoothing the products of gradients.\n# A larger value results in smoother, more coherent orientation fields by integrating over a larger neighborhood.\nRHO = 0.6\n\n# Multiple of RHO at which the gradients are truncated.\n# A larger value requires a larger margin around the image, set in VERTICAL_PADDING.\nTRUNCATE = 4\n\n# Padding to avoid border artifacts\n# Default value is TRUNCATE * RHO + 0.5\n# VERTICAL_PADDING = 10\n\n# Number of slices to load into memory at a time during processing.\n# This affects memory usage and processing speed. Adjust based on system capacity.\nN_CHUNK = 20\n\n# Enable GPU computation during the structure tensor calculation (True/False)\nUSE_GPU = True\n\n# Whether to save the orientation vectors (as .npy) (True/False)\n# Use for 3D vector/fiber visualisation\nWRITE_VECTORS = True\n\n# Specify the processing direction:\n#   - True: Process slices from the beginning (0) to the end.\n#   - False: Process slices from the end to the beginning.\nREVERSE = False\n\n\n[ANGLE CALCULATION]\n# Whether to save the helical and intrusion angles and fractional anisotropy (True/False)\nWRITE_ANGLES = True\n\n# Choose which angle pair to compute:\n#   ha_ia  \u2192 Helix Angle / Intrusion Angle (standard myocardial architecture)\n#   az_el  \u2192 Azimuth / Elevation (generic vector orientation in 3D)\nANGLE_MODE = ha_ia\n\n# Coordinates of points along the left ventricle axis.\n# The first point should be coordinates of the mitral valve point in the volume ([X, Y, Z])\n# The last point should be coordinates of the apex point in the volume ([X, Y, Z])\n# Intermediate points will be interpolated to create a curved centre line.\nAXIS_POINTS = [104,110,116], [41,87,210], [68,95,162]\n\n\n[TEST]\n# Enable test mode:\n#   - True: Process and plot only a single slice for testing.\n#   - False: Perform the full processing on the entire volume.\nTEST = True\n\n# Specify the slice number to process when test mode is enabled.\nN_SLICE_TEST = 155\n\n\n[OUTPUT]\n# Path to the folder where the results will be saved\nOUTPUT_PATH =./output\n\n# Output file format for the results (e.g., jp2 or tif).\n# Default format is jp2\nOUTPUT_FORMAT = tif\n\n# Type of pixel values in the output file:\n#   - \"8bit\" for grayscale 8-bit images\n#   - \"rgb\" for 3-channel color images\nOUTPUT_TYPE = 8bit\n</code></pre> <p>Note</p> <p>Modify the configuration file as needed to fit your dataset.</p>"},{"location":"reference/configuration/#explanation-of-parameters","title":"Explanation of Parameters","text":""},{"location":"reference/configuration/#dataset","title":"<code>[DATASET]</code>","text":"<ul> <li><code>IMAGES_PATH</code>: Path to the input dataset containing 3D images.</li> <li><code>VOXEL_SIZE</code>: Voxel size of the dataset in micrometers.</li> <li><code>MASK_PATH</code>: Path to the binary segmentation mask. Leave blank if no mask is available.</li> </ul> <p>Note</p> <p>The mask volume can be downscaled compared to the heart volume. The binning factor will be estimated automatically and the mask will be upscaled accordingly.</p>"},{"location":"reference/configuration/#structure-tensor-calculation","title":"<code>[STRUCTURE TENSOR CALCULATION]</code>","text":"<ul> <li><code>SIGMA</code>: Noise scale before gradient computation. Helps reduce noise while preserving structures.</li> <li><code>RHO</code>: Integration scale for smoothing tensor components. Larger values yield smoother orientation fields.</li> <li><code>TRUNCATE</code>: Multiple of RHO for defining the gradient filter kernel size.</li> <li><code>VERTICAL_PADDING (optional)</code>: Extra padding (in voxels) to avoid edge artifacts. If not set, defaults to TRUNCATE * RHO + 0.5.</li> <li><code>N_CHUNK</code>: Number of slices to process simultaneously.</li> <li><code>USE_GPU</code>: Enable GPU computation (requires CuPy).</li> <li><code>WRITE_VECTORS</code>: Save orientation 3rd vector as <code>.npy</code> files.</li> </ul> <p>Warning</p> <p>Orientation vectors are saved in <code>float32</code> format and may consume significant disk space.</p> <ul> <li><code>REVERSE</code>: Process volume from end to start if set to <code>True</code>.</li> </ul> <p>Note</p> <p>The structure tensor calculation is performed using the <code>structure-tensor</code> Python package with optional CUDA support.</p>"},{"location":"reference/configuration/#angle-calculation","title":"<code>[ANGLE CALCULATION]</code>","text":"<ul> <li><code>WRITE_ANGLES</code>: Save helix and intrusion angles and fractional anisotropy values.</li> <li><code>AXIS_POINTS</code>: List of 3D points <code>[X, Y, Z]</code> along the ventricle axis. Typically, the first and last points correspond to the mitral valve and apex. Intermediate points help create a curved axis via interpolation.</li> </ul>"},{"location":"reference/configuration/#test","title":"<code>[TEST]</code>","text":"<ul> <li><code>TEST</code>: Enable test mode to process a single slice.</li> <li><code>N_SLICE_TEST</code>: Index of the slice to test.</li> </ul> <p>Note</p> <p>Use test mode to verify processing on a small subset before running on the full volume.</p>"},{"location":"reference/configuration/#output","title":"<code>[OUTPUT]</code>","text":"<ul> <li><code>OUTPUT_PATH</code>: Directory where results are saved.</li> <li><code>OUTPUT_FORMAT</code>: Output format (<code>jp2</code> or <code>tif</code>).</li> <li><code>OUTPUT_TYPE</code>: Image bit depth and channel type:<ul> <li><code>8bit</code>: grayscale 8-bit image.</li> <li><code>rgb</code>: 3-channel color image.</li> </ul> </li> </ul>"}]}